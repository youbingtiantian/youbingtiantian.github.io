<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>Mini-Vue-Computed | 油 饼 甜 甜 | 火鸡程序员的备忘录</title><meta name="author" content="油饼甜甜"><meta name="description" content="随便放点什么..."><meta name="keywords" content="Vue3,computed,计算属性"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="Mini-Vue-Computed"><meta property="og:site_name" content="油 饼 甜 甜"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="油 饼 甜 甜" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">油 饼 甜 甜</a></h1><p class="site-description">火鸡程序员的备忘录</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>Mini-Vue-Computed</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/2023/05/29/Mini-Vue-Computed/" rel="bookmark"><time class="entry-date published" datetime="2023-05-29T13:54:00.000Z">2023-05-29</time></a></span></div><div class="article-content"><div class="entry"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇是关于 vue3 的「computed」如何实现</p><p>基于源码的结构实现，并不会一步步说明搭建项目的过程…（麻烦</p><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>下面的截图是 vue 官网对于 computed 的描述</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/youbingtiantian/youbingtiantian.github.io/img/Mini-Vue-Computed/computed.png"></p><p>由此可以知道「computed」是返回了一个只读的响应式「ref」对象，那么我们首先创建「computed」函数吧</p><p><img src="https://cdn.jsdelivr.net/gh/youbingtiantian/youbingtiantian.github.io/img/Mini-Vue-Computed/computedFunc.png"></p><p>在这个函数中首先声明一个 getter，然后判断当前传入进来的是不是一个函数，返回一个布尔值，当前如果传递进来的是一个函数的话，将当前函数赋给 getter，然后 new ComputedRefImpl 传入当前 getter 进去，最后 return 实例 cRef，接下来，我们看一下 ComputedRefImpl 这个类中干了什么</p><h2 id="ComputedRefImpl"><a href="#ComputedRefImpl" class="headerlink" title="ComputedRefImpl"></a>ComputedRefImpl</h2><p><img src="https://cdn.jsdelivr.net/gh/youbingtiantian/youbingtiantian.github.io/img/Mini-Vue-Computed/ComputedRefImpl.png"></p><p>当前这个类就是关于 computed 的核心，在此我们简要的实现，导入的方法在前面的章节中有实现</p><p>在这里先定义一些公共和私有的属性，我们要注意，这里也定义了「__v_isRef」说明 computed 实际上也是实现的一个类似于 ref 的操作，通过类去构建 get 和 set 方法来操作依赖</p><p>这里还有一个关键属性，「_dirty」这个属性是一个脏数据的意思，他的作用是在什么时候需要触发更新，众所周知，computed 计算属性，只会在依赖的响应式数据发生变化时才会触发执行，「_dirty」就是做这样的一个工作</p><p>当 new ComputedRefImpl 时，constructor 内部 new 了 ReactiveEffect，这个是我们之前实现过的，将当前函数传入，然后传入了第二个匿名函数，这个函数有一个概念叫做「调度器」，在特定情况下触发，内部其实就是「triggerRefValue」触发依赖</p><p>同时我们将这个 this.effect 添加了一个 computed 属性</p><p>这里的 get value 会在第一次使用 computed 的值时候触发，那么将首先执行「trackrefValue」,在这里因为第一次使用时 「_dirty」是 true 所以会进入 if，将其改为 false，标记着现在没有更改数据，不需要在重复更新，同时我们执行了 run 方法，等同于执行了「getterOrOptions」获得了一个 computed 计算之后的值，同时返回。</p><p>因为执行了 this.effect.run,那么我们知道，等于执行了「getterOrOptions」这个函数，这个函数是我们在 computed 使用时传递进来的函数，内部我们做了一个计算值的操作，这其中引用了 ref 的值或者 reactive 的值，那么我们会触发它们的“get”，那么这个依赖也被收集了。</p><h2 id="Html-讲述"><a href="#Html-讲述" class="headerlink" title="Html 讲述"></a>Html 讲述</h2><p><img src="https://cdn.jsdelivr.net/gh/youbingtiantian/youbingtiantian.github.io/img/Mini-Vue-Computed/computedHtml.png"></p><p>对照这个描述，其实 computed 中使用了 obj.name，代表这个函数也被收入到这个 name 到依赖中，下面的 effect 中使用了 computedObj，代表着这个依赖也被收集了，上面说过。</p><p>并且有「_dirty」的介入，不会重复触发，然后在 2 秒后我们修改了 obj.name，这里将会触发 obj.name 的依赖，其中包含了 computed 中的函数，那么会重新执行 return “我是” + “李四”，这里会返回新值，那么 computedObj 也修改了，就会触发 computed 自己的依赖，也就是那一句对节点的 innerText 操作，达到修改目的。</p><p>整体其实是一个闭环的操作</p><p>部分代码没有放出，我们在 ReactiveEffect 类的构造函数中还需要接受一个新参数名为「scheduler」就是 new ReactiveEffect 的时候传递的第二个参数 调度器。</p><p>同时我们当时给 this.effect 加的一个 computed 属性会在触发依赖的时候进行判断，如果有的话，那么就代表着肯定是 computed 的值，那么必然也会有「scheduler」，执行顺序一定是先执行计算属性的，然后在执行普通响应式的，不然会造成死循环</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于「computed」计算属性，我的个人理解不是很全面，只能说大概清楚他的过程和实现逻辑，文字复述不知道怎么样说清晰一些，如果有误，请添加「关于」中的联系方式沟通，一起学习共勉！</p><p><font color="red">编辑文章是一个比较细腻的工作，每天没有很长的时间去做一些美化的工作，所以大篇幅的文字看起来很枯燥，虽然主要功能是给我自己看以及记录的过程，但是后面会尽量做的美观清晰一些。😊</font></p></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/Vue/">Vue</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/Vue3/">Vue3</a><a href="/tags/computed/">computed</a><a href="/tags/计算属性/">计算属性</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2023 油饼甜甜</p></footer></div></div></body></html>